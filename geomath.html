<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>گراف‌کش | رسم توابع ریاضی</title>

  <!-- فونت فارسی پیشنهادی (وزیر) -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css" rel="stylesheet">

  <style>
    /* ---------- تنظیمات پایه و پالت ---------- */
    :root{
      --bg-1: #06131a;     /* زمینه تیره */
      --bg-2: #0b1722;     /* زمینه تاریک‌تر */
      --glass: rgba(255,255,255,0.06);
      --glass-2: rgba(255,255,255,0.04);
      --muted: #9fb3c8;
      --text: #e9f6ff;
      --accent: linear-gradient(90deg, #6ee7f7 0%, #a78bfa 50%, #fb7185 100%);
      --neon-line-start: #5eead4;
      --neon-line-end: #a78bfa;
      --neon-shadow: 0 0 18px rgba(167,139,250,0.14);
      --glass-blur: 14px;
      --glass-radius: 14px;
      --glass-border: rgba(255,255,255,0.06);
      --card-bg: rgba(255,255,255,0.03);
    }

    html,body{height:100%;margin:0;font-family: "Vazir", "Vazir FD", Tahoma, Arial, sans-serif;background: radial-gradient(1200px 600px at 10% 20%, rgba(4,50,70,0.18), transparent 8%), radial-gradient(800px 400px at 85% 80%, rgba(90,10,120,0.12), transparent 6%), linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; direction:rtl;}
    *{box-sizing:border-box}

    /* ---------- پس‌زمینه: المان‌های بلور رنگی ---------- */
    .bg-decor {
      position:fixed; inset:0; pointer-events:none; z-index:0; overflow:hidden;
      /* light fog */
      background-image:
        radial-gradient(ellipse at 50% 10%, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.0) 30%),
        radial-gradient(ellipse at 80% 90%, rgba(0,0,0,0.12) 0%, rgba(0,0,0,0.0) 35%);
    }
    .blob {
      position:absolute;
      filter: blur(28px);
      opacity:0.6;
      mix-blend-mode: screen;
      border-radius: 50%;
      transform: translate3d(0,0,0);
      transition: transform 8s ease-in-out, opacity 6s ease-in-out;
      animation: floaty 12s ease-in-out infinite;
      will-change: transform, opacity;
      z-index:0;
    }
    /* تعریف چند پلاگ رنگی شفاف */
    .blob.b1{ width:360px;height:360px; left:6%; top:8%; background: radial-gradient(circle at 30% 30%, rgba(174,230,255,0.28), rgba(45,150,200,0.16)); animation-delay:0s;}
    .blob.b2{ width:260px;height:260px; right:8%; top:14%; background: radial-gradient(circle at 20% 20%, rgba(180,150,255,0.26), rgba(120,80,220,0.12)); animation-delay:2s;}
    .blob.b3{ width:300px;height:300px; left:20%; bottom:6%; background: radial-gradient(circle at 10% 70%, rgba(120,255,200,0.22), rgba(60,190,140,0.12)); animation-delay:4s;}
    .blob.b4{ width:220px;height:220px; right:18%; bottom:14%; background: radial-gradient(circle at 60% 40%, rgba(255,140,100,0.2), rgba(240,90,30,0.08)); animation-delay:6s;}
    .blob.b5{ width:180px;height:420px; left:50%; top:18%; transform: translateX(-50%) rotate(12deg); background: radial-gradient(circle at 50% 20%, rgba(255,235,120,0.26), rgba(200,160,40,0.08)); animation-delay:8s;}

    @keyframes floaty {
      0% { transform: translateY(0) scale(1); opacity:0.55; }
      50%{ transform: translateY(-24px) scale(1.04); opacity:0.7; }
      100%{ transform: translateY(0) scale(1); opacity:0.55; }
    }

    /* ---------- صفحه کلی اپ ---------- */
    .container {
      position:relative;
      z-index:2;
      max-width:1300px;
      margin:28px auto;
      padding:20px;
      display:flex;
      gap:20px;
      align-items:flex-start;
    }

    /* ---------- نوار ناوبری راست‌چین ---------- */
    .navbar {
      position:fixed; top:18px; right:18px; left:18px;
      display:flex; justify-content:space-between; align-items:center; gap:12px;
      z-index:4;
      pointer-events:auto;
    }
    .nav-left { display:flex; gap:12px; align-items:center; }
    .brand {
      display:flex; gap:12px; align-items:center; padding:10px 14px; border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04); backdrop-filter: blur(var(--glass-blur));
      box-shadow: 0 6px 24px rgba(2,6,23,0.55);
      color:var(--text); font-weight:700;
    }
    .brand .logo {
      width:34px;height:34px;border-radius:8px;background:linear-gradient(90deg,#6ee7f7,#a78bfa); box-shadow:0 6px 16px rgba(167,139,250,0.12);
      display:flex;align-items:center;justify-content:center;color:#021226;font-weight:800;
      font-size:16px;
    }
    .nav-items {
      display:flex; gap:8px; align-items:center;
    }
    .nav-item {
      padding:9px 12px;border-radius:10px;font-size:14px;color:var(--muted);
      background:transparent;border:1px solid transparent;
      transition: all .24s ease; cursor:pointer;
    }
    .nav-item:hover { color:var(--text); transform:translateY(-3px); background: rgba(255,255,255,0.02); border-color: rgba(255,255,255,0.03) }

    /* ---------- پنل سمت راست: کنترل‌ها ---------- */
    .panel {
      width:360px; min-width:280px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--glass-radius);
      padding:16px;
      border:1px solid var(--glass-border);
      backdrop-filter: blur(var(--glass-blur));
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    }
    h1 { margin:6px 0 10px 0; font-size:18px; color:var(--text) }
    label { display:block; font-size:13px; color:var(--muted); margin-top:10px }
    input[type="text"], input[type="number"], select {
      width:100%; padding:9px 10px; margin-top:8px; border-radius:10px;
      background: rgba(255,255,255,0.02); color:var(--text); border:1px solid rgba(255,255,255,0.04);
      font-size:14px;
    }
    .row{display:flex; gap:8px; margin-top:10px}
    .row > *{flex:1}
    .btn {
      display:inline-block; padding:9px 12px; border-radius:10px; font-weight:700; cursor:pointer;
      border:none; color:#012; background:linear-gradient(90deg,#f07878,#6196ff); box-shadow: 0 8px 24px rgba(167,139,250,0.08);
    }
    .btn.secondary { background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); font-weight:600 }
    .small { font-size:12px; color:var(--muted) }
    .func-list { margin-top:12px; max-height:240px; overflow:auto; padding:8px; background: rgba(0,0,0,0.18); border-radius:10px; }
    .func-item { display:flex; align-items:center; justify-content:space-between; padding:8px; border-radius:8px; margin-bottom:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent) }
    .legend-dot { width:12px;height:12px;border-radius:50%;display:inline-block;margin-left:8px }

    /* ---------- بخش کانواس (چپ) ---------- */
    .canvas-wrap { flex:1; min-height:560px; display:flex; flex-direction:column; gap:12px; z-index:3; }
    .canvas-card {
      flex:1; padding:12px; border-radius:16px; border:1px solid rgba(255,255,255,0.04);
      background: linear-gradient(180deg, rgba(2,6,23,0.28), rgba(2,6,23,0.22));
      backdrop-filter: blur(var(--glass-blur));
      box-shadow: 0 10px 40px rgba(2,6,23,0.6);
    }
    canvas { width:100%; height:100%; border-radius:12px; display:block; background: linear-gradient(180deg, rgba(2,10,20,0.2), rgba(2,6,12,0.06)); }

    .toolbar { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:6px }
    .coords { color:var(--muted); font-size:13px }

    /* ---------- فوتر نئونی با لاین Glow ---------- */
    footer {
      position:fixed; left:0; right:0; bottom:0; z-index:5; pointer-events:auto;
      display:flex; justify-content:center; align-items:center; padding:12px 24px; gap:18px;
      background: linear-gradient(180deg, rgba(0,0,0,0.05), rgba(0,0,0,0.02));
      border-top: 1px solid rgba(255,255,255,0.03);
      backdrop-filter: blur(6px);
    }
    .neon-line {
      position:absolute; top:0; left:0; right:0; height:3px;
      background: linear-gradient(90deg, rgba(94,234,212,0.95), rgba(167,139,250,0.95));
      box-shadow: 0 0 26px rgba(167,139,250,0.16), 0 0 8px rgba(94,234,212,0.12);
      transform-origin:left;
      animation: neon-scroll 5s linear infinite;
      border-bottom-left-radius:6px; border-bottom-right-radius:6px;
    }
    @keyframes neon-scroll {
      0%{ background-position: 0% 0% }
      50%{ background-position: 100% 0% }
      100%{ background-position: 0% 0% }
    }
    footer .footer-content { display:flex; gap:14px; align-items:center; color:var(--muted); font-size:13px }
    footer a { color:var(--muted); text-decoration:none; border-bottom:1px dotted rgba(255,255,255,0.02) }
    footer a:hover { color:var(--text) }

    /* ---------- ریسپانسیو ---------- */
    @media (max-width:1100px) {
      .container { padding:12px; max-width:1000px; gap:12px }
      .panel { width:320px }
    }
    @media (max-width:900px) {
      .container { flex-direction:column-reverse; padding:12px; max-width:900px }
      .panel { width:100% }
      .navbar { left:12px; right:12px; top:12px }
    }
    @media (max-width:420px) {
      .brand { padding:8px 10px }
      .nav-items { display:none } /* منوی ساده در موبایل */
      footer { padding:10px }
    }
  </style>
</head>
<body>

  <!-- المان‌های پس‌زمینه بلور رنگی -->
  <div class="bg-decor" aria-hidden="true">
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>
    <div class="blob b4"></div>
    <div class="blob b5"></div>
  </div>

  <!-- نوار ناوبری -->
  <nav class="navbar" role="navigation" aria-label="ناوبری اصلی">
    <div class="nav-left">
      <div class="brand" role="img" aria-label="گراف‌کش">
        <div class="logo">گ</div>
        <div style="display:flex;flex-direction:column;line-height:1">
          <div style="font-weight:800">گراف‌کش</div>
          <div style="font-size:11px;color:var(--muted);margin-top:2px">رسم تابع — تعاملی</div>
        </div>
      </div>
    </div>

    <div class="nav-items" role="list">

    </div>
  </nav>

  <!-- محتوای اصلی -->
  <main class="container" role="main" aria-label="ابزار رسم تابع">
    <!-- پنل کنترل‌ها (راست) -->
    <aside class="panel" role="complementary" aria-label="کنترل‌ها">
      <h1>رسم تابع — وارد کنید</h1>

      <label for="expr">عبارت تابع (تابعی از x)</label>
      <input id="expr" type="text" placeholder="مثال: sin(x) + 0.5*x" value="sin(x)">

      <div class="row">
        <div>
          <label for="xmin">xmin</label>
          <input id="xmin" type="number" value="-10" step="0.1">
        </div>
        <div>
          <label for="xmax">xmax</label>
          <input id="xmax" type="number" value="10" step="0.1">
        </div>
      </div>

      <div class="row">
        <div>
          <label for="samples">نمونه‌ها (دقت)</label>
          <input id="samples" type="number" value="1200" min="50" max="10000">
        </div>
        <div>
          <label for="color">رنگ</label>
          <input id="color" type="color" value="#6ee7f7">
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="addBtn" class="btn" aria-label="اضافه کردن و رسم">اضافه و رسم</button>
        <button id="clearBtn" class="btn secondary" aria-label="پاک کردن همه">پاک کردن</button>
      </div>

      <label style="margin-top:12px">توابع رسم‌شده</label>
      <div id="functions" class="func-list" aria-live="polite"></div>

      <div class="row" style="margin-top:10px">
        <button id="exportPng" class="btn secondary">ذخیره PNG</button>
        <button id="resetView" class="btn secondary">ریست نما</button>
      </div>

      <div style="margin-top:12px" class="small">
        نکته: می‌توانید از توابع ریاضی جاوااسکریپت با نگارش راحت استفاده کنید. نماد توان ^ تبدیل خواهد شد. توابع نمونه: sin, cos, tan, exp, log, sqrt, PI
      </div>
    </aside>

    <!-- بخش کانواس (چپ) -->
    <section class="canvas-wrap" aria-label="بخش رسم">
      <div class="toolbar">
        <div class="coords" id="coords">x = — , y = —</div>
        <div class="small">کلیک+درگ برای جابه‌جایی — چرخ موس برای زوم</div>
      </div>

      <div class="canvas-card" role="region" aria-label="نمودار">
        <canvas id="plot" width="1200" height="700" aria-label="نمودار توابع"></canvas>
      </div>

    </section>
  </main>

  <!-- فوتر با نئون -->
  <footer role="contentinfo" aria-label="پاورقی">
    <div class="neon-line" aria-hidden="true"></div>
    <div class="footer-content">
      <div>© هکتوریا | تمامی حقوق محفوظ است.</div>
    </div>
  </footer>

  <!-- ---------- اسکریپت اپ رسم نمودار ---------- -->
  <script>
  (function(){
    // ---------- تنظیمات و عناصر ----------
    const canvas = document.getElementById('plot');
    const ctx = canvas.getContext('2d', {alpha:true});
    const DPR = Math.max(1, window.devicePixelRatio || 1);

    const exprInput = document.getElementById('expr');
    const xminInput = document.getElementById('xmin');
    const xmaxInput = document.getElementById('xmax');
    const samplesInput = document.getElementById('samples');
    const colorInput = document.getElementById('color');
    const addBtn = document.getElementById('addBtn');
    const clearBtn = document.getElementById('clearBtn');
    const functionsDiv = document.getElementById('functions');
    const exportBtn = document.getElementById('exportPng');
    const resetViewBtn = document.getElementById('resetView');
    const coordsDiv = document.getElementById('coords');

    // داده‌های نمودار
    let plots = []; // {id, expr, fn, color, visible, _lastSamples}
    let nextId = 1;

    // نمای (view)
    let view = {
      xmin: parseFloat(xminInput.value) || -10,
      xmax: parseFloat(xmaxInput.value) || 10,
      offsetX: 0,
      offsetY: 0,
      scale: 1
    };

    // اندازه‌گذاری canvas با DPR
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * DPR);
      canvas.height = Math.floor(rect.height * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);
    // اولیه
    setTimeout(resizeCanvas, 50);

    // تبدیل دنیا <-> پیکسل
    function worldToPixel(x, y, bounds) {
      const w = bounds.width, h = bounds.height;
      const xmin = view.xmin, xmax = view.xmax;
      const xspan = (xmax - xmin);
      const px = ((x - xmin) / xspan) * w + view.offsetX;
      const yr = bounds.yrange;
      const py = (1 - ((y - yr.ymin) / (yr.ymax - yr.ymin))) * h + view.offsetY;
      return {px, py};
    }
    function pixelToWorld(px, py, bounds) {
      const w = bounds.width, h = bounds.height;
      const xmin = view.xmin, xmax = view.xmax;
      const x = xmin + ((px - view.offsetX) / w) * (xmax - xmin);
      const yr = bounds.yrange;
      const y = yr.ymax - ((py - view.offsetY)/h) * (yr.ymax - yr.ymin);
      return {x,y};
    }

    // تبدیل عبارت -> تابع امن (با with(Math))
    function compileExpression(expr) {
      const clean = expr.replace(/[\u200B-\u200D\uFEFF]/g, '')
                        .replace(/\^/g, '**')
                        .replace(/π/g, 'PI')
                        .replace(/÷/g, '/');
      try {
        const fn = new Function('x', 'with (Math) { return (' + clean + '); }');
        // تست اجرا
        const test = fn(1);
        return fn;
      } catch (e) {
        return null;
      }
    }

    // نمونه‌برداری
    function sampleFunction(fn, xmin, xmax, samples) {
      const arr = [];
      const step = (xmax - xmin) / Math.max(1, samples-1);
      for (let i=0;i<samples;i++){
        const x = xmin + i*step;
        let y;
        try {
          y = fn(x);
          if (!isFinite(y)) y = NaN;
        } catch (e) {
          y = NaN;
        }
        arr.push({x,y});
      }
      return arr;
    }

    // محاسبه بازه y از روی نمونه‌ها
    function computeYRange(allSamples) {
      let ymin = Infinity, ymax = -Infinity;
      allSamples.forEach(s => {
        s.forEach(pt=>{
          if (!Number.isFinite(pt.y)) return;
          if (pt.y < ymin) ymin = pt.y;
          if (pt.y > ymax) ymax = pt.y;
        });
      });
      if (!isFinite(ymin) || !isFinite(ymax)) { ymin = -10; ymax = 10; }
      if (ymin === ymax) { ymin -= 1; ymax += 1; }
      const pad = (ymax - ymin) * 0.12;
      return {ymin: ymin - pad, ymax: ymax + pad};
    }

    // رسم کلی
    function draw() {
      const rect = canvas.getBoundingClientRect();
      const width = rect.width, height = rect.height;
      ctx.clearRect(0,0,width,height);

      // نمونه‌ها
      const xmin = view.xmin, xmax = view.xmax;
      const samples = Math.max(100, Math.min(6000, parseInt(samplesInput.value) || 1200));
      const allSamples = [];
      plots.forEach(p => {
        if (!p.visible) return;
        const s = sampleFunction(p.fn, xmin, xmax, samples);
        p._lastSamples = s;
        allSamples.push(s);
      });

      // yrange
      const yrange = computeYRange(allSamples);
      const bounds = {width, height, yrange};

      // شبکه و محورها
      drawGrid(ctx, bounds);
      drawLegend(ctx);

      // نمودارها
      plots.forEach(p => { if (p.visible) drawPlot(ctx, p, bounds); });

    }

    // خطوط شبکه و تیک‌ها
    function drawGrid(ctx, bounds) {
      const w = bounds.width, h = bounds.height;
      ctx.save();
      // background subtle
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0,0,w,h);

      const xTicks = niceTicks(view.xmin, view.xmax, 8);
      const yTicks = niceTicks(bounds.yrange.ymin, bounds.yrange.ymax, 7);

      // خطوط شبکه
      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      xTicks.forEach(tx => {
        const px = ((tx - view.xmin)/(view.xmax - view.xmin))*w + view.offsetX;
        ctx.moveTo(px, 0); ctx.lineTo(px, h);
      });
      yTicks.forEach(ty => {
        const py = (1 - ((ty - bounds.yrange.ymin)/(bounds.yrange.ymax - bounds.yrange.ymin)))*h + view.offsetY;
        ctx.moveTo(0, py); ctx.lineTo(w, py);
      });
      ctx.stroke();

      // محورها
      ctx.beginPath();
      ctx.lineWidth = 1.6;
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      if (bounds.yrange.ymin <= 0 && bounds.yrange.ymax >= 0) {
        const py = (1 - ((0 - bounds.yrange.ymin)/(bounds.yrange.ymax - bounds.yrange.ymin)))*h + view.offsetY;
        ctx.moveTo(0, py); ctx.lineTo(w, py);
      }
      if (view.xmin <= 0 && view.xmax >= 0) {
        const px = ((0 - view.xmin)/(view.xmax - view.xmin))*w + view.offsetX;
        ctx.moveTo(px, 0); ctx.lineTo(px, h);
      }
      ctx.stroke();

      // برچسب‌ها
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = '12px Vazir, Tahoma, Arial';
      ctx.textAlign = 'center';
      xTicks.forEach(tx => {
        const px = ((tx - view.xmin)/(view.xmax - view.xmin))*w + view.offsetX;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText(formatNumber(tx), px, h - 6);
      });
      ctx.textAlign = 'left';
      yTicks.forEach(ty => {
        const py = (1 - ((ty - bounds.yrange.ymin)/(bounds.yrange.ymax - bounds.yrange.ymin)))*h + view.offsetY;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText(formatNumber(ty), 8, py - 4);
      });

      ctx.restore();
    }

    // رسم یک نمودار
    function drawPlot(ctx, plot, bounds) {
      const samples = plot._lastSamples || [];
      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = 2.4;
      ctx.strokeStyle = plot.color || '#6ee7f7';
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      let started = false;
      for (let i=0;i<samples.length;i++){
        const pt = samples[i];
        if (!Number.isFinite(pt.y)) { started = false; continue; }
        const p = worldToPixel(pt.x, pt.y, bounds);
        if (!started) { ctx.moveTo(p.px, p.py); started = true; } else { ctx.lineTo(p.px, p.py); }
      }
      ctx.stroke();
      ctx.restore();
    }

    // رسم لیجن (سمت بالا-راست داخل کانواس)
    function drawLegend(ctx) {
      const left = 12; let top = 12;
      ctx.save();
      ctx.font = '12px Vazir, Tahoma';
      plots.forEach((p,i)=>{
        const y = top + i*22;
        ctx.fillStyle = p.color;
        ctx.fillRect(left, y, 12, 12);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillText(p.expr, left + 18, y + 11);
      });
      ctx.restore();
    }

    // مدیریت لیست توابع در پنل سمت راست
    function refreshFunctionList() {
      functionsDiv.innerHTML = '';
      plots.forEach(p=>{
        const el = document.createElement('div');
        el.className = 'func-item';
        const left = document.createElement('div');
        left.innerHTML = '<div style="display:flex;align-items:center"><div class="legend-dot" style="background:'+p.color+'"></div><div style="font-weight:700;">'+escapeHtml(p.expr)+'</div></div>';
        const right = document.createElement('div');
        right.style.display='flex'; right.style.gap='8px';
        const visBtn = document.createElement('button'); visBtn.className='btn secondary'; visBtn.textContent = p.visible ? 'پنهان' : 'نمایش';
        visBtn.onclick = () => { p.visible = !p.visible; visBtn.textContent = p.visible ? 'پنهان' : 'نمایش'; draw(); };
        const delBtn = document.createElement('button'); delBtn.className='btn'; delBtn.style.background='linear-gradient(90deg,#fb7185,#f97316)'; delBtn.textContent='حذف';
        delBtn.onclick = () => { plots = plots.filter(x=>x.id !== p.id); refreshFunctionList(); draw(); };
        right.appendChild(visBtn); right.appendChild(delBtn);
        el.appendChild(left); el.appendChild(right);
        functionsDiv.appendChild(el);
      });
      if (plots.length === 0) functionsDiv.innerHTML = '<div class="small" style="padding:8px;color:var(--muted)">هیچ تابعی رسم نشده</div>';
    }

    // اضافه کردن تابع
    addBtn.addEventListener('click', ()=>{
      const expr = exprInput.value.trim();
      if (!expr) { alert('لطفاً عبارت تابع را وارد کنید.'); return; }
      const fn = compileExpression(expr);
      if (!fn) { alert('عبارت نامعتبر است — نگارش را بررسی کنید.'); return; }
      const color = colorInput.value || '#6ee7f7';
      const item = { id: 'f' + (nextId++), expr, fn, color, visible:true };
      plots.push(item);
      refreshFunctionList();
      const newxmin = parseFloat(xminInput.value); const newxmax = parseFloat(xmaxInput.value);
      if (!isNaN(newxmin) && !isNaN(newxmax) && newxmin < newxmax) { view.xmin = newxmin; view.xmax = newxmax; }
      draw();
    });

    clearBtn.addEventListener('click', ()=>{
      if (!confirm('آیا مطمئن هستید همه توابع حذف شوند؟')) return;
      plots = [];
      refreshFunctionList();
      draw();
    });

    exportBtn.addEventListener('click', ()=>{
      const dataUrl = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = dataUrl; a.download = 'plot.png';
      document.body.appendChild(a); a.click(); a.remove();
    });

    resetViewBtn.addEventListener('click', ()=>{
      view.offsetX = 0; view.offsetY = 0; view.scale = 1;
      view.xmin = parseFloat(xminInput.value) || -10;
      view.xmax = parseFloat(xmaxInput.value) || 10;
      draw();
    });

    // تعاملات ماوس: پن و زوم، نمایش مختصات
    let dragging = false; let lastMouse = null;
    canvas.addEventListener('mousedown', (e)=>{
      dragging = true; lastMouse = {x:e.clientX, y:e.clientY}; canvas.style.cursor='grabbing';
    });
    window.addEventListener('mouseup', ()=>{
      dragging = false; canvas.style.cursor='default';
    });
    window.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // تعیین yrange برای تبدیل
      const all = plots.filter(p=>p.visible).map(p=>p._lastSamples || []);
      const yr = computeYRange(all.length ? all : [[{x:0,y:-10},{x:1,y:10}]]);
      const bounds = { width: rect.width, height: rect.height, yrange: yr };

      const world = pixelToWorld(mouseX, mouseY, bounds);
      coordsDiv.textContent = 'x = ' + formatNumber(world.x) + ' , y = ' + formatNumber(world.y);

      if (dragging && lastMouse) {
        const dx = e.clientX - lastMouse.x;
        const dy = e.clientY - lastMouse.y;
        view.offsetX += dx;
        view.offsetY += dy;
        lastMouse = {x:e.clientX, y:e.clientY};
        draw();
      }
    });

    // wheel برای زوم حول نشانگر
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const zoomFactor = 1 + (e.deltaY > 0 ? 0.08 : -0.08);
      const bounds = { width: rect.width, height: rect.height, yrange: computeYRange(plots.filter(p=>p.visible).map(p=>p._lastSamples || [])) };
      const worldBefore = pixelToWorld(mouseX, 0, bounds).x;
      const cx = worldBefore;
      const newXmin = cx + (view.xmin - cx) * zoomFactor;
      const newXmax = cx + (view.xmax - cx) * zoomFactor;
      view.xmin = newXmin; view.xmax = newXmax;
      draw();
    }, {passive:false});

    // فرمت عدد
    function formatNumber(v) {
      if (!isFinite(v)) return 'NaN';
      if (Math.abs(v) >= 1e5 || (Math.abs(v) < 1e-3 && v !== 0)) return v.toExponential(3);
      return (Math.round(v*100000)/100000).toString();
    }

    // تیک‌های زیبا
    function niceTicks(min, max, maxTicks=10) {
      if (!isFinite(min) || !isFinite(max)) return [];
      const span = max - min;
      if (span <= 0) return [min];
      const step0 = Math.pow(10, Math.floor(Math.log10(span / maxTicks)));
      const error = (maxTicks * step0) / span;
      let step = step0;
      if (error <= 0.15) step = step0 * 10;
      else if (error <= 0.35) step = step0 * 5;
      else if (error <= 0.75) step = step0 * 2;
      const start = Math.ceil(min / step) * step;
      const ticks = [];
      for (let t = start; t <= max + 1e-9; t += step) ticks.push(Number(parseFloat(t).toFixed(12)));
      ticks.unshift(min); ticks.push(max);
      return Array.from(new Set(ticks)).sort((a,b)=>a-b);
    }

    // HTML escape ساده برای نمایش
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
    }

    // مقداردهی اولیه: یک تابع نمونه
    (function init(){
      const defaultFn = compileExpression(exprInput.value || 'sin(x)');
      if (defaultFn) plots.push({ id:'f0', expr: exprInput.value || 'sin(x)', fn: defaultFn, color: colorInput.value || '#6ee7f7', visible:true });
      refreshFunctionList();
      draw();
    })();

    // تنظیم مجدد اندازه اگر ورودی xmin/xmax تغییر کند
    xminInput.addEventListener('change', ()=>{ view.xmin = parseFloat(xminInput.value) || view.xmin; draw(); });
    xmaxInput.addEventListener('change', ()=>{ view.xmax = parseFloat(xmaxInput.value) || view.xmax; draw(); });
    samplesInput.addEventListener('change', ()=> draw());

    // (امنیتی) جلوگیری از XSS در ورودی‌های توابع داخل متن نهایی انجام نمی‌دهیم، اما استفاده از new Function الزاماً باید با احتیاط باشد.
    // اگر نیاز دارید تا ورودی‌ها ایمن‌تر تحلیل شوند، پیشنهاد می‌کنم از کتابخانه‌ای مثل math.js استفاده کنیم.

  })();
  </script>
</body>
</html>